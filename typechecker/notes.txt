-- Val  # 10
-- Type # int
-- ST   # P!l(int)
-- Expr # let x = P!l(10) ; return ()
^ this is an expression which has sequencing `;` a send operation `P!l(10)` and a function call (?) with `return ()`

tcVal :: Env -> Val -> Maybe Type

tcExpr :: Env -> ST -> Expr -> Maybe Type x ST



 let x = send msg(10) to P ; return ()



Implement a type checker !! Essentially I'll provide an AST (I think) to my typechecker which must implement all the typing rules defined in the Maty paper

- No parser needed
- No semantics needed


---


TV-LAM
If M is well-typed as a computation of type B when x is available as type A and the session transitions from S to T, then ฮป x. M is a function from A to B (with session precondition S and postcondition T).


TV-HANDLER

`handler p {l_i(x_i) -> M_i}_i` the handler is typable with type `Handler(p&{l_i(A_i).S_i}_i) if each continuation M_i is typable with session precondition S_i where the environment is extended with x_i of type A_i, and all branches have the postcondition `end`.


--

T-APP
A function application V W is typable by T-App provided that the precondition in the function type matches the current precondition, and advances the postcondition to that of the function type

T-SPAWN
The spawn M term spawns a new actor that evaluates term M; rule T-Spawn types spawn M with the unit type if the spawned thread M must has return type 1 and pre- and postconditions `end` (since the spawned computation is not yet in a session and so cannot communicate)


T-SEND
This rule types a send computation p ! l(V) if l is contained within the selection session precondition, and if V has the corresponding type; the postcondition is the session continuation for the specified branch


T-SUSPEND
when an actor wishes to receive a message, it must suspend itself and install a message handler using suspend V. The T-Suspend rule states that suspend V is typable if the handler is compatible with the current session type precondition; since the computation does not return, it can be given an arbitrary return type and postcondition.


T-NEWAP
Sessions are initiated using access points: we create an access point for a session with roles and types (p_i : s_i)_i using newAP(p_i:s_i)_i, which must annotated with the set of roles and local types to be involved in the session (T-NewAP). The rule ensures that the session types satisfy a safety property; we will describe this further in ยง3, but at a high level, if a set of session types is safe then the types are guaranteed never to cause a runtime type error due to a communication mismatch.

T-REGISTER
An actor can register to take part in a session as role p on access point V using register V p M; term M is a callback to be invoked once the session is established. Rule T-Register ensures that the access point must contain a session type T associated with role p, and since the initiation callback will be evaluated when the session is established, M must be typable under session type T. Since neither newAP nor register perform any communication, the session types are unaltered.
